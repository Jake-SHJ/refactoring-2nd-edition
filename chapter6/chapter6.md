# chapter 6 기본적인 리팩터링

카탈로그의 첫머리는 가장 기본적이고 많이 사용해서 제일 먼저 배워야 하는 리팩터링들로 시작한다.

## 함수 추출하기 \_ Extract Function

1. 배경

   - 코드 조각을 찾아 무슨 일을 하는지 파악한 다음, 독립된 함수로 추출하고 목적에 맞는 이름을 붙인다.
   - '목적과 구현을 분리'하는 방식이 가장 합리적인 기준
     - 무슨 일을 하는지 파악하는 데 한참이 걸린다면 그 부분을 함수로 추출한 뒤 '무슨 일'에 걸맞는 이름을 짓는다.
     - 함수명을 통해 목적을 분명히 하고, 구현은 신경쓰지 않도록 할수 있다.
   - 함수가 짧으면 캐싱하기가 더 쉽기 때문에 컴파일러가 최적화하는 데 유리할 때가 많다.

   > 최적화를 할 때에는 다음 두 규칙을 따르기 바란다. 첫 번째, 하지 마라. 두 번째(전문가 한정), 아직 하지 마라 \_ M. A. 잭슨

   - 짧은 함수의 이점은 이름을 잘 지어야만 발휘되므로 이름 짓기에 특별히 신경 써야 한다.

2. 절차

   - 함수를 새로 만들고 목적을 잘 드러내는 이름을 붙인다('어떻게'가 아닌 '무엇을' 하는지가 드러나야 한다).
   - 추출할 코드를 원본 함수에서 복사하여 새 함수에 붙여넣는다.
   - 추출한 코드 중 원본 함수의 지역 변수를 참조하거나 추출한 함수의 유효범위를 벗어나는 변수는 없는지 검사한다. 있다면 매개변수로 전달한다.
   - 변수를 다 처리했다면 컴파일한다.
   - 원본 함수에서 추출한 코드 부분을 새로 만든 함수를 호출하는 문장으로 바꾼다(즉, 추출한 함수로 일을 위임한다).
   - 테스트한다.
   - 다른 코드에 방금 추출한 것과 똑같거나 비슷한 코드가 없는지 살핀다. 있다면 방금 추출한 새 함수를 호출하도록 바꿀지 검토한다.

3. 예시
   - [유효범위를 벗어나는 변수가 없을 때](ex_6_1/1.js)
   - [지역 변수를 사용할 때](ex_6_1/2.js)
   - [지역 변수의 값을 변경할 때](ex_6_1/3.js)

## 함수 인라인하기 \_ Inline Function

1. 배경

   - 때로는 함수 본문이 이름만큼 명확한 경우도 있다.
   - 간접 호출은 유용할 수도 있지만, 쓸데없는 간접 호출은 거슬릴 뿐이다.
   - 리팩터링 과정에서 잘못 추출된 함수들도 다시 인라인한다.
   - 다른 함수로 단순히 위임하기만 하는 함수들이 너무 많아서 위임 관계가 복잡하게 얽혀 있으면 인라인해버린다.

2. 절차

   - 다형 메서드인지 확인한다(서브클래스에서 오버라이드하는 메서드는 인라인하면 안 된다).
   - 인라인할 함수를 호출하는 곳을 모두 찾는다.
   - 각 호출문을 함수 본문으로 교체한다.
   - 하나씩 교체할 때마다 테스트한다.
   - 함수 정의(원래 함수)를 삭제한다.

3. 예시

   - [간단한 예제](ex_6_2/1.js)

## 변수 추출하기 \_ Extract Variable

1. 배경

   - 표현식이 너무 복잡해서 이해하기 어려울 때, 지역 변수를 활용하면 표현식을 쪼개 관리하기 더 쉽게 만들 수 있다.
   - 추가한 변수는 디버거에 중단점을 지정하거나 상태를 출력하는 문장을 추가할 수 있어서 디버깅에도 도움이 된다.
   - 변수 추출을 고려한다고 함은 표현식에 이름을 붙이고 싶다는 뜻이다.

2. 절차

   - 추출하려는 표현식에 부작용(side effect)은 없는지 확인한다.
   - 불변 변수를 하나 선언하고 이름을 붙일 표현식의 복제본을 대입한다.
   - 원본 표현식을 새로 만든 변수로 교체한다.
   - 테스트한다.
   - 표현식을 여러 곳에서 사용한다면 각각을 새로 만든 변수로 교체한다. 하나 교체할 때마다 테스트한다.

3. 예시

   - [간단한 계산식](ex_6_3/1.js)
   - [클래스 안에서](ex_6_3/2.js)

## 변수 인라인하기 \_ Inline Variable

1. 배경

   - 변수의 이름이 원래 표현식과 다를 바 없을 때, 또 주변 코드를 리팩터링하는 데 방해가 되는 경우

2. 절차

   - 대입문의 우변(표현식)에서 부작용이 생기지는 않는지 확인한다.
   - 변수가 불변으로 선언되지 않았다면 불변으로 만든 후 테스트한다.
   - 이 변수를 가장 처음 사용하는 코드를 찾아서 대입문 우변의 코드로 바꾼다.
   - 테스트한다.
   - 변수를 사용하는 부분을 모두 교체할 때까지 이 과정을 반복한다.
   - 변수 선언문과 대입문을 지운다.
   - 테스트한다.

## 함수 선언 바꾸기 \_ Change Function Declaration

1. 배경

   - 함수 선언은 각 부분이 서로 맞물리는 방식을 표현하며, 실질적으로 소프트웨어 시스템의 구성 요소를 조립하는 연결부 역할을 한다.
   - 연결부를 잘 정의하면 시스템에 새로운 부분을 추가하기가 쉬워진다.
   - 연결부에서 가장 중요한 요소는 함수의 이름이다.
   - 매개변수는 함수가 외부 세계와 어우러지는 방식을 정의하고, 함수를 사용하는 문맥을 설정한다.

2. 절차

   - 단번에 고칠 수 있는 경우라면 간단한 절차를, 점진적으로 수정해야 하는 경우 마이그레이션 절차를 따른다.
     - 간단한 절차
       - 매개변수를 제거하려거든 먼저 함수 본문에서 제거 대상 매개변수를 참조하는 곳은 없는지 확인한다.
       - 메서드 선언을 원하는 형태로 바꾼다.
       - 기존 메서드 선언을 참조하는 부분을 모두 찾아서 바뀐 형태로 수정한다.
       - 테스트한다.
     - 마이그레이션 절차
       - 이어지는 추출 단계를 수월하게 만들어야 한다면 함수의 본문을 적절히 리팩터링한다.
       - 함수 본문을 새로운 함수로 추출한다.
       - 추출한 함수에 매개변수를 추가해야 한다면 '간단한 절차'를 따라 추가한다.
       - 테스트한다.
       - 기존 함수를 인라인한다.
       - 이름을 임시로 붙여뒀다면 함수 선언 바꾸기를 한 번 더 적용해서 원래 이름으로 되돌린다.
       - 테스트한다.

3. 예시

   - [함수 이름 바꾸기](ex_6_5/1.js)
   - [매개변수 추가하기](ex_6_5/2.js)
   - [매개변수를 속성으로 바꾸기](ex_6_5/3.js)

## 변수 캡슐화하기 \_ Encapsulate Variable

1. 배경

   - 함수는 데이터보다 다루기가 수월하다.
   - 데이터는 참조하는 모든 부분을 한 번에 바꿔야 코드가 제대로 작동한다.
   - 접근할 수 있는 범위가 넓은 데이터를 옮길 때는 먼저 그 데이터로의 접근을 독점하는 함수를 만드는 식으로 캡슐화하는 것이 가장 좋은 방법일 때가 많다.
   - 데이터 캡슐화는 데이터를 변경하고 사용하는 코드를 감시할 수 있는 확실한 통로가 되어주기 때문에 변경 전 검증이나 변경 후 추가 로직을 쉽게 끼워 넣을 수 있다.
   - 불변 데이터는 가변 데이터보다 캡슐화할 이유가 적다.

2. 절차

   - 변수로의 접근과 갱신을 전담하는 캡슐화 함수들을 만든다.
   - 정적 검사를 수행한다.
   - 변수를 직접 참조하던 부분을 모두 적절한 캡슐화 함수 호출로 바꾼다. 하나씩 바꿀 때마다 테스트한다.
   - 변수의 접근 범위를 제한한다.
   - 테스트한다.
   - 변수 값이 레코드라면 레코드 캡슐화하기를 적용할지 고려해본다.

3. 예시

   - [예시](ex_6_6/1.js)

## 변수 이름 바꾸기 \_ Rename Variable

1. 배경

   - 명확한 프로그래밍의 핵심은 이름짓기다.
   - 특히 이름의 중요성은 그 사용 범위에 영향을 많이 받는다.
   - 함수 호출 한 번으로 끝나지 않고 값이 영속되는 필드라면 이름에 더 신경 써야 한다.

2. 절차

   - 폭넓게 쓰이는 변수라면 변수 캡슐화하기를 고려한다.
   - 이름을 바꿀 변수를 참조하는 곳을 모두 찾아서, 하나씩 변경한다. (변수 값이 변하지 않는다면 다름 이름으로 복제본을 만들어서 하나씩 점진적으로 변경한다.)
   - 테스트한다.

3. 예시

   - [예시](ex_6_7/1.js)

## 매개변수 객체 만들기 \_ Introduce Parameter Object

1. 배경

   - 데이터 뭉치를 데이터 구조로 묶으면 데이터 사이의 관계가 명확해진다는 이점을 얻는다.
   - 데이터 구조를 받게 하면 매개변수 수가 줄어들고, 항상 똑같은 이름을 사용하기 때문에 일관성도 높여준다.
   - 새로 만든 데이터 구조가 문제 영역을 훨씬 간결하게 표현하는 새로운 추상 개념으로 격상되면서, 코드의 개념적인 그림을 다시 그릴 수도 있다.

2. 절차

   - 적당한 데이터 구조가 아직 마련되어 있지 않다면 새로 만든다.
   - 테스트한다.
   - 함수 선언 바꾸기로 새 데이터 구조를 매개변수로 추가한다.
   - 테스트한다.
   - 함수 호출 시 새로운 데이터 구조 인스턴스를 넘기도록 수정한다. 하나씩 수정할 때마다 테스트한다.
   - 기존 매개변수를 사용하던 코드를 새 데이터 구조의 원소를 사용하도록 바꾼다.
   - 다 바꿨다면 기존 매개변수를 제거하고 테스트한다.

3. 예시

   - [예시](ex_6_8/1.js)

## 여러 함수를 클래스로 묶기 \_ Combine Functions into Class

1. 배경

   - 클래스는 데이터와 함수를 하나의 공유 환경으로 묶은 후, 다른 프로그램 요소와 어우러질 수 있도록 그중 일부를 외부에 제공한다.
   - 클래스로 묶으면 이 함수들이 공유하는 공통 환경을 더 명확하게 표현할 수 있고, 각 함수에 전달되는 인수를 줄여서 객체 안에서의 함수 호출을 간결하게 만들 수 있다.
   - 이미 만들어진 함수들을 재구성할 때는 물론, 새로 만든 클래스와 관련하여 놓친 연산을 찾아서 새 클래스의 메서드로 뽑아내는 데도 좋다.

2. 절차

   - 함수들이 공유하는 공통 데이터 레코드를 캡슐화한다.
   - 공통 레코드를 사용하는 함수 각각을 새 클래스로 옮긴다.
   - 데이터를 조작하는 로직들은 함수로 추출해서 새 클래스로 옮긴다.

3. 예시

   - [예시](ex_6_9/1.js)

## 여러 함수를 변환 함수로 묶기 \_ Combine Functions into Transform

1. 배경

   - 변환 함수는 원본 데이터를 입력받아서 필요한 정보를 모두 도출한 뒤, 각각을 출력 데이터의 필드에 넣어 반환한다.
   - 여러 함수를 클래스로 묶기로 처리해도 된다. (원본 데이터가 코드 안에서 갱신될 때에는 클래스로 묶는 편이 훨씬 낫다)
   - 도출 로직이 중복되는 것을 피하기 위해서 사용되며, 근처에 있지 않은 함수를 발견하기 어려울 때가 많으므로 함수로 추출만 하는 것 보다 유용하게 사용될 수 있다.

2. 절차

   - 변환할 레코드를 입력받아서 값을 그대로 반환하는 변환 함수를 만든다.
   - 묶을 함수 중 함수 하나를 골라서 본문 코드를 변환 함수로 옯기고, 처리 결과를 레코드에 새 필드로 기록한다. 그런 다음 클라이언트 코드가 이 필드를 사용하도록 수정한다.
   - 테스트한다.
   - 나머지 관련 함수도 위 과정에 따라 처리한다.

3. 예시

   - [예시](ex_6_10/1.js)
