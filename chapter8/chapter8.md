# chapter 8 기능 이동

- 요소를 다른 컨텍스트(클래스나 모듈등)로 옮기는 일 역시 리팩터링의 중요한 축이다.

## 함수 옮기기 \_ Move Function

1. 배경

   - 좋은 소프트웨어 설계의 핵심은 모듈화가 얼마나 잘 되어 있느냐를 뜻하는 모듈성(modularity)이다.
   - 모듈성이란 프로그램의 어딘가를 수정하려 할 때 해당 기능과 깊이 관련된 작은 일부만 이해해도 가능하게 해주는 능력이다.
   - 모듈성을 높이려면 서로 연관된 요소들을 함께 묶고, 요소 사이의 연결 관계를 쉽게 찾고 이해할 수 있도록 해야 한다.
   - 프로그래밍 언어들은 저마다늬 모듈화 수단을 제공하며, 각각의 수단이 함수가 살아 숨 쉬는 컨텍스트를 만들어준다.
   - 대상 함수를 호출하는 함수들은 무엇인지, 대상 함수가 호출하는 함수들은 또 무엇이 있는지, 대상 함수가 사용하는 데이터는 무엇인지를 살펴보고 컨텍스트의 위치를 결정한다.

2. 절차

   - 선택한 함수가 현재 컨텍스트에서 사용 중인 모든 프로그램 요소를 살펴본다. 이 요소들 중에도 함께 옮겨야 할 게 있는지 고민해본다.
   - 선택한 함수가 다형 메서드인지 확인한다.
   - 선택한 함수를 타깃 컨텍스트로 복사한다(이때 원래의 함수를 소스 함수라 하고 복사해서 만든 새로운 함수를 타깃 함수라 한다). 타깃 함수가 새로운 터전에 잘 자리 잡도록 다듬는다.
   - 정적 분석을 수행한다.
   - 소스 컨텍스트에서 타깃 함수를 참조할 방법을 찾아 반영한다.
   - 소스 함수를 타깃 함수의 위임 함수가 되도록 수정한다.
   - 테스트한다.
   - 소스 함수를 인라인할지 고민해본다.

3. 예시

   - [중첩 함수를 최상위로 옮기기](ex_8_1/1.js)
   - [다른 클래스로 옯기기](ex_8_1/2.js)

## 필드 옮기기 \_ Move Field

1. 배경

   - 프로그램의 상단 부분이 동작을 구현하는 코드로 이뤄지지만 프로그램의 진짜 힘은 데이터 구조에서 나온다.
   - 하지만 훌륭한 프로그램이 갖춰야 할 다른 요인들과 마찬가지로, 제대로 하기가 어렵다.
   - 현재 데이터 구조가 적절치 않음을 깨닫게 되면 곧바로 수정해야 한다.

2. 절차

   - 소스 필드가 캡슐화되어 있지 않다면 캡슐화한다.
   - 테스트한다.
   - 타깃 객체에 필드(와 접근자 메서드들)를 생성한다.
   - 정적 검사를 수행한다.
   - 소스 객체에서 타깃 객체를 참조할 수 있는지 확인한다.
   - 접근자들이 타깃 필드를 사용하도록 수정한다.
   - 테스트한다.
   - 소스 필드를 제거한다.
   - 테스트한다.

3. 예시

   - [예시](ex_8_2/1.js)
   - [공유 객체로 이동하기](ex_8_2/2.js)

## 문장을 함수로 옮기기 \_ Move Statements into Function

1. 배경

   - 중복 제거는 코드를 건강하게 관리하는 가장 효과적인 방법 중 하나다.
   - 문장들을 함수로 옮기려면 그 문장들이 피호출 함수의 일부라는 확신이 있어야 한다.

2. 절차

   - 반복 코드가 함수 호출 부분과 멀리 떨어져 있다면 문장 슬라이드하기를 적용해 근처로 옮긴다.
   - 타깃 함수를 호출하는 곳이 한 곳뿐이면, 단순히 소스 위치에서 해당 코드를 잘라내어 피호출 함수로 복사하고 테스트한다. 이 경우라면 나머지 단계는 무시한다.
   - 호출자가 둘 이상이면 호출자 중 하나에서 '타깃 함수 호출 부분과 그 함수로 옮기려는 문장들을 함께' 다른 함수로 추출한다. 추출한 함수에 기억하기 쉬운 임시 이름을 지어준다.
   - 다른 호출자 모두가 방금 추출한 함수를 사용하도록 수정한다. 하나씩 수정할 때마다 테스트한다.
   - 모든 호출자가 새로운 함수를 사용하게 되면 원래 함수를 새로운 함수 안으로 인라인한 후 원래 함수를 제거한다.
   - 새로운 함수의 이름을 원래 함수의 이름으로 바꿔준다.

3. 예시

   -[예시](ex_8_3/1.js)

## 문장을 호출한 곳으로 옮기기 \_ Move Statements to Callers

1. 배경

   - 함수는 프로그래머가 쌓아 올리는 추상화의 기본 빌딩 블록이다.
   - 추상화라는 것이 그 경계를 항상 올바르게 긋기가 만만치 않다. 그래서 코드베이스의 기능 범위가 달라지면 추상화의 경계도 움직이게 된다.
   - 작은 변경이라면 문장을 호출한 곳으로 옮기는 것으로 충분하지만, 호출자와 호출 대상의 경계를 완전히 다시 그어야 할 때도 있다.

2. 절차

   - 호출자가 한두 개뿐이고 피호출 함수도 간단한 단순한 상황이면, 피호출 함수의 처음(혹은 마지막) 줄(들)을 잘라내어 호출자(들)로 복사해 넣는다(필요하면 적당히 수정한다). 테스트만 통과하면 이번 리팩터링은 여기서 끝이다.
   - 더 복잡한 상황에서는, 이동하지 '않길' 원하는 모든 문장을 함수로 추출한 다음 검색하기 쉬운 임시 이름을 지어준다.
   - 원래 함수를 인라인한다.
   - 추출된 함수의 이름을 원래 함수의 이름으로 변경한다(함수 이름 바꾸기).

3. 예시

   - [예시](ex_8_4/1.js)

## 인라인 코드를 함수 호출로 바꾸기 \_ Replace Inline Code with Function Call

1. 배경

   - 함수는 여러 동작을 하나로 묶어준다.
   - 함수의 이름이 코드의 동작 방식보다는 목적을 말해주기 때문에 함수를 활용하면 코드를 이해하기가 쉬워진다.
   - 똑같은 코드를 반복하는 대신 함수를 호출하면 되기 때문에 중복을 없애는 데도 효과적이다.
   - 이미 존재하는 함수와 똑같은 일을 하는 인라인 코드를 발견하면 보통은 해당 코드를 함수 호출로 대체하길 원할 것이다.
   - 예외가 있다면, 기존 함수의 코드를 수정하더라도 인라인 코드의 동작은 바뀌지 않아야 할 때이다.

2. 절차

   - 인라인 코드를 함수 호출로 대체한다.
   - 테스트한다.

3. 옮긴이의 말

   - 함수 추출하기와 이번 리팩터링의 차이는 인라인 코드를 대체할 함수가 이미 존재하느냐 여부다.
   - 사용 중인 프로그래밍 언어의 표준 라이브러리나 플랫폼이 제공하는 API를 잘 파악하고 있을수록 이번 리팩터링의 활용 빈도가 높아질 것이다.
