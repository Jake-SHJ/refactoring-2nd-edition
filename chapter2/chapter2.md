# chapter 2 정리

## 리팩터링 정의

리팩터링은 결국 동작을 보존하는 작은 단계들을 거쳐 코드를 수정하고, 이러한 단계들을 순차적으로 연결하여 큰 변화를 만들어내는 일이다.

> 누군가 "리팩터링하다가 코드가 깨져서 며칠이나 고생했다"라고 한다면, 십중팔구 리팩터링한 것이 아니다.

## 리팩터링하는 이유

> 리팩터링이 소프트웨어의 모든 문제점을 해결하는 만병 통치약은 절대 아니다. 하지만 코드를 건강한 상태로 유지하는 데 도와주는 약임은 분명하다.

리팩터링하면...

1. 소프트웨어 설계가 좋아진다
2. 소프트웨어를 이해하기 쉬워진다
3. 버그를 쉽게 찾을 수 있다
4. 프로그래밍 속도를 높일 수 있다

## 언제 리팩터링해야 할까?

3의 법칙

1. 처음에는 그냥 한다.
2. 비슷한 일을 두 번째로 하게 되면, 일단 계속 진행한다.
3. 비슷한 일을 세 번째 하게 되면 리팩터링한다.

- 준비를 위한 리팩터링: 기능을 쉽게 추가할 수 있도록 만들기
- 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기
- 쓰레기 줍기 리팩터링: 간단히 수정할 수 있는 것은 즉시 고치기
- 계획된 리팩터링과 수시로 하는 리팩터링: 리팩터링 시간을 일정에 따로 잡아두지 않고, 다른 일을 하는 중에 처리한다.

  > 보기 싫은 코드를 발견하면 리팩터링하자. 그런데 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다.

  > _무언가 수정하려 할 때는 먼저 수정하기 쉽게 정돈하고(단, 만만치 않을 수 있다) 그런 다음 쉽게 수정하자. - 켄트 벡_

- 오래 걸리는 리팩터링: 팀 전체가 리팩터링에 매달리지 않고, 리팩터링해야 할 코드와 관련한 작업을 할 때마다 조금씩 개선한다.
- 코드 리뷰에 리팩터링 활용하기
- 리팩터링하지 말아야 할 때
  - 외부 API 다루듯 호출해서 쓰는 코드라면 지저분해도 그냥 둔다. 내부 동작을 이해해야 할 시점에 리팩터링해야 효과를 제대로 볼 수 있다.
  - 리팩터링하는 것보다 처음부터 새로 작성하는 게 더 쉬울 때도 리팩터링하지 않는다.

## 리팩터링 시 고려할 문제

- 새 기능 개발 속도 저하

  - 리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다.
  - 리팩터링의 본질은 코드베이스를 예쁘게 꾸미는 데 있는 것이 아니라, 오로지 경제적인 이유로 하는 것이다.

- 코드 소유권

  - 코드 소유권을 작은 단위로 나눠 엄격하게 관리하는 것이 아닌, 코드의 소유권을 팀에 두는 것이 바람직하다.

- 브랜치

  - 기능별 브랜치들이 독립적으로 개발되는 기간이 길어질수록 머지가 복잡해지는 문제가 발생한다.
  - 기능별 브랜치의 통합 주기를 짧게 관리하는 방식을 지속적 통합(CI), 또는 트렁크 기반 개발(TBD)이라 한다.

- 테스팅

  - 리팩터링하기 위해서는 자가 테스트 코드를 마련해야 한다.
  - 자가 테스트 코드는 리팩터링 과정에서 버그가 생길 위험이 아주 크다는 불안감을 해소할 수 있다.
  - 자가 테스트 코드는 통합 과정에서 발생하는 의미 충돌을 잡는 메커니즘으로 활용할 수 있어서 자연스럽게 CI와도 밀접하게 연관된다. CI에 통합된 테스트는 지속적 배포(CD)의 핵심이기도 하다.

- 레거시 코드

  - 테스트를 갖추고 있더라도 복잡하게 얽힌 레거시 코드를 아름다운 코드로 단번에 리팩터링하는 데는 낙관적이지 않다.
  - 코드의 한 부분을 훑고 넘어갈 때마다 예전보다 조금이라도 개선하려고 노력한다. 규모가 크다면 자주 보는 부분을 더 많이 리팩터링한다. 코드를 훑게 되는 횟수가 많다는 말은 그 부분을 이해하기 쉽게 개선했을 때 얻는 효과도 그만큼 크다는 뜻이니 당연히 이렇게 해야 한다.

- 데이터 베이스

  - 진화형 데이터베이스 설계와 데이터베이스 리팩터링 기법은 현재 널리 적용되고 있다. 이 기법의 핵심은 커다란 변경들을 쉽게 조합하고 다룰 수 있는 데이터 마이그레이션 스크립트를 작성하고, 접근 코드와 데이터베이스 스키마에 대한 구조적 변경을 이 스크립트로 처리하게끔 통합하는 데 있다.
  - 데이터베이스 리팩터링은 프로덕션 환경에서 여러 단계로 나눠서 릴리스하는 것이 대체로 좋다는 점에서 다른 리팩터링과 다르다.

## 리팩터링, 아키텍처, 애그니(YAGNI)

- 리팩터링이 아키텍처에 미치는 실질적인 효과는 요구사항 변화에 자연스럽게 대응하도록 코드베이스를 잘 설계해준다는 데 있다.
- 현재까지 파악한 요구사항만을 해결하는 소프트웨어를 구축하되, 리팩터링을 미루면 훨씬 힘들어진다는 확신이 들 때만 유연성 메커니즘을 미리 추가한다. 이런 식으로 설계하는 방식을 간결한 설계, 점진적 설계, YAGNI (You aren't going to need it) 등으로 부른다.
- YAGNI 방식은 진화형 아키텍처 원칙이 발전하는 계기가 됐다(진화형 아키텍처는 아키텍처 관련 결정을 시간을 두고 반복해 내릴 수 있다는 장점을 활용하는 패턴과 실천법을 추구한다).

## 리팩터링과 소프트웨어 개발 프로세스

- 익스트림 프로그래밍의 두드러진 특징은 지속적 통합, 자가 프로세스 코드, 리팩터링 등의 개성이 강하면서 상호 의존하는 기법들을 하나로 묶은 프로세스라는 점이다. 자가 테스트 코드와 리팩터링을 묶어서 테스트 주도 개발(TDD)이라 한다.
- 애자일을 제대로 적용하려면 리팩터링에 대한 팀의 역량과 열정이 뒷받침되어 프로세스 전반에 리팩터링이 자연스럽게 스며들도록 해야 한다.
- 추측에 근거한 수많은 유연성 메커니즘을 갖춘 시스템보다는 단순한 시스템이 변경하기가 훨씬 쉽다.

## 리팩터링과 성능

> 내가 성능을 무시하는 이유는 설계의 순수성을 우선시하거나 조만간 더 빠른 하드웨어가 나오리라 믿기 때문이 아니다.

- 리팩터링하면 소프트웨어가 느려질 수도 있는 건 사실이다. 하지만 그와 동시에 성능을 튜닝하기는 더 쉬워진다. 하드 리얼타임 시스템을 제외한 소프트웨어를 빠르게 만드는 비결은, 먼저 튜닝하기 쉽게 만들고 나서 원하는 속도가 나게끔 튜닝하는 것이다.

> 시스템에 대해 잘 알더라도 섣불리 추측하지 말고 성능을 측정해봐야 한다. 그러면 새로운 사실을 배우게 되는데, 십중팔구 내가 잘못 알고 있었음을 깨닫게 된다.

- 프로그램을 잘 리팩터링해두면 최적화에 두 가지 면에서 도움이 된다.

  - 성능 튜닝에 투입할 시간을 벌 수 있다.
  - 리팩터링이 잘 되어 있는 프로그램은 성능을 더 세밀하게 분석할 수 있다.

- 단기적으로 보면 리팩터링 단계에서는 성능이 느려질 수도 있지만, 최적화 단계에서 코드를 튜닝하기 훨씬 쉬어지기 때문에 결국 더 빠른 소프트웨어를 얻게 된다.
