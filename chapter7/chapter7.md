# chapter 7 캡슐화

모듈을 분리하는 가장 중요한 기준은 아마도 시스템에서 각 모듈이 자신을 제외한 다른 부분에 드러내지 않아야 할 비밀을 얼마나 잘 숨기느냐에 있을 것이다.

## 레코드 캡슐화하기 \_ Encapsulate Record

1. 배경

   - 단순한 레코드는 계산해서 얻을 수 있는 값과 그렇지 않은 값을 명확히 구분해 저장해야 한다는 단점이 있다.
   - 가변 데이터를 저장하는 용도로는 레코드보다 객체를 선호하는 편이다. 불변이라면 레코드에 저장한다.
   - 레코드의 구조는 필드 이름을 노출하는 형태와 내가 원하는 이름을 쓸 수 있는 형태 두 가지로 구분할 수 있고, 후자의 경우 hash, map, hashmap, dictionary, associative array 등의 이름으로 라이브러리에서 제공한다.
   - 해시맵은 필드를 명확히 알려주지 않는다는 단점이 있는데, 사용되는 부분이 적다면 문제되지 않지만 사용하는 곳이 많을수록 불분명함으로 인해 발생하는 문제가 커지게 되므로 명시적 레코드 혹은 클래스로 리팩터링하는 것이 좋다.

2. 절차

   - 레코드를 담은 변수를 캡슐화한다.
   - 레코드를 감싼 단순한 클래스로 해당 변수의 내용을 교체한다. 이 클래스에 원본 레코드를 반환하는 접근자도 정의하고, 변수를 캡슐화하는 함수들이 이 접근자를 사용하도록 수정한다.
   - 테스트한다.
   - 원본 레코드 대신 새로 정의한 클래스 타입의 객체를 반환하는 함수들을 새로 만든다.
   - 레코드를 반환하는 예전 함수를 사용하는 코드를 새로 만든 함수를 사용하도록 바꾼다. 필드에 접근할 때는 객체의 접근자를 사용한다. 적절한 접근자가 없다면 추가한다. 한 부분을 바꿀 때마다 테스트한다.
   - 클래스에서 원본 데이터를 반환하는 접근자와 원본 레코드를 반환하는 함수들을 제거한다.
   - 테스트한다.
   - 레코드의 필드도 데이터 구조인 중첩 구조라면 레코드 캡슐화하기와 컬렉션 캡슐화하기를 재귀적으로 적용한다.

3. 예시

   - [간단한 레코드 캡슐화하기](ex_7_1/1.js)
   - [중첩된 레코드 캡슐화하기](ex_7_1/2.js)

## 컬렉션 캡슐화하기 \_ Encapsulate Collection

1. 배경

   - 컬렉션 변수로의 접근을 캡슐화하면서 게터가 컬렉션 자체를 반환하도록 한다면, 그 컬렉션을 감싼 클래스가 눈치채지 못하는 상태에서 컬렉션의 원소들이 바뀌어버릴 수 있다.
   - 컬렉션 변경자 메서드를 만들어서 항상 컬렉션을 소유한 클래스를 통해서만 원소를 변경하도록 하면 프로그램을 개선하면서 컬렉션 변경 방식도 원하는 대로 수정할 수 있다.
   - 이보다는 컬렉션 게터가 원본 컬렉션을 반환하지 않게 만들어서 클라이언트가 실수로 컬렉션을 바꿀 가능성을 차단하는 게 낫다.
   - 가장 흔히 사용하는 방식은 컬렉션 게터를 제공하되 내부 컬렉션의 복제본을 반환하는 것이다.

2. 절차

   - 아직 컬렉션을 캡슐화하지 않았다면 변수 캡슐화하기부터 한다.
   - 컬렉션에 원소를 추가/제거하는 함수를 추가한다.
   - 정적 검사를 수행한다.
   - 컬렉션을 참조하는 부분을 모두 찾는다. 컬렉션의 변경자를 호출하는 코드가 모두 앞에서 추가한 추가/제거 함수를 호출하도록 수정한다. 하나씩 수정할 때마다 테스트한다.
   - 컬렉션 게터를 수정해서 원본 내용을 수정할 수 없는 읽기전용 프락시나 복제본을 반환하게 한다.
   - 테스트한다.

3. 예시

   - [예시](ex_7_2/1.js)

## 기본형을 객체로 바꾸기 \_ Replace Primitive with Object

1. 배경

   - 개발 초기에는 단순한 정보를 숫자나 문자열 같은 간단한 데이터 항목으로 표현할 때가 많지만, 개발이 진행되면서 더 이상 간단하지 않게 변한다.
   - 단순한 출력 이상의 기능이 필요해지는 순간 그 데이터를 표현하는 전용 클래스를 정의하는 편이다.
   - 시작은 기본형 데이터를 단순히 감싼 것과 큰 차이가 없을 것이라 효과가 미미하지만, 나중에 특별한 동작이 필요해지면 이 클래스에 추가하면 되니 프로그램이 커질수록 점점 유용한 도구가 된다.
   - 초보 프로그래머에게는 직관에 어긋나 보일 수 있지만 경험 많은 개발자들은 여러가지 리팩터링 중에서도 가장 유용한 것으로 손꼽는다.

2. 절차

   - 아직 변수를 캡슐화하지 않았다면 캡슐화한다.
   - 단순한 값 클래스를 만든다. 생성자는 기존 값을 인수로 받아서 저장하고, 이 값을 반환하는 게터를 추가한다.
   - 정적 검사를 수행한다.
   - 값 클래스의 인스턴스를 새로 만들어서 필드에 저장하도록 세터를 추가한다. 이미 있다면 타입을 적절히 변경한다.
   - 새로 만든 클래스의 게터를 호출한 결과를 반환하도록 게터를 수정한다.
   - 테스트한다.
   - 함수 이름을 바꾸면 원본 접근자의 동작을 더 잘 드러낼 수 있는지 검토한다.

3. 예시

   - [예시](ex_7_3/1.js)

## 임시 변수를 질의 함수로 바꾸기 \_ Replace Temp with Query

1. 배경

   - 함수 안에서 어떤 코드의 결괏값을 뒤에서 다시 참조할 목적으로 임시 변수를 쓰기도 한다.
   - 임시 변수를 사용하면 값을 계산하는 코드가 반복되는 걸 줄이고 값의 의미를 설명할 수도 있어서 유용하지만, 아예 함수로 만들어 사용하는 편이 나을 때가 많다.
   - 긴 함수의 한 부분을 별도 함수로 추출하고자 할 때 먼저 변수들을 각각의 함수로 만들면 일이 수월해진다. 추출한 함수에 변수를 따로 전달할 필요가 없기 때문이다.
   - 추출한 함수와 원래 함수의 경계가 더 분명해지기도 하는데, 그러면 부자연스러운 의존 관계나 부수효과를 찾고 제거하는 데 도움이 된다.
   - 최상위 함수로 추출하면 매개변수가 너무 많아져서 함수를 사용하는 장점이 줄어들고 중첩 함수를 사용하면 이런 문제는 없지만 관련 함수들과 로직을 널리 공유하는데 한계가 있으므로, 이 리팩터링은 클래스 안에서 사용할 때 효과가 가장 크다.
   - 스냅샷 용도로 쓰이는 변수에는 이 리팩터링을 적용하면 안 된다.

2. 절차

   - 변수가 사용되기 전에 값이 확실히 결정되는지, 변수를 사용할 때마다 계산 로직이 매번 다른 결과를 내지는 않는지 확인한다.
   - 읽기전용으로 만들 수 있는 변수는 읽기전용으로 만든다.
   - 테스트한다.
   - 변수 대입문을 함수로 추출한다.
   - 테스트한다.
   - 변수 인라인하기로 임시 변수를 제거한다.

3. 예시

   - [예시](ex_7_4/1.js)

## 클래스 추출하기 \_ Extract Class

1. 배경

   - 메서드와 데이터가 너무 많은 클래스는 이해하기가 쉽지 않으니 잘 살펴보고 적절히 분리하는 것이 좋다.
   - 일부 데이터와 메서드를 따로 묶을 수 있다면 어서 분리하라는 신호다. 함께 변경되는 일이 많거나 서로 의존하는 데이터들도 분리한다.
   - 개발 후반으로 접어들면 서브클래스가 만들어지는 방식에서 왕왕 징후가 나타나기도 하는데 작은 일부의 기능만을 위해 서브클래스를 만들거나, 확장해야 할 기능이 무엇이냐에 따라 서브클래스를 만드는 방식도 달라진다면 클래스를 나눠야 한다는 신호다.

2. 절차

   - 클래스의 역할을 분리할 방법을 정한다.
   - 분리될 역할을 담당할 클래스를 새로 만든다.
   - 원래 클래스의 생성자에서 새로운 클래스의 인스턴스를 생성하여 필드에 저장해둔다.
   - 분리될 역할에 필요한 필드들을 새 클래스로 옮긴다. 하나씩 옮길 때마다 테스트한다.
   - 메서드들도 새 클래스로 옮긴다. 이때 저수준 메서드, 즉 다른 메서드를 호출하기보다는 호출을 당하는 일이 많은 메서드부터 옮긴다. 하나씩 옮길 때마다 테스트한다.
   - 양쪽 클래스의 인터페이스를 살펴보면서 불필요한 메서드를 제거하고, 이름도 새로운 환경에 맞게 바꾼다.
   - 새 클래스를 외부로 노출할지 정한다. 노출하려거든 새 클래스에 참조를 값으로 바꾸기를 적용할 지 고민해본다.

3. 예시

   - [예시](ex_7_5/1.js)
