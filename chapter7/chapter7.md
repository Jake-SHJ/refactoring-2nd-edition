# chapter 7 캡슐화

모듈을 분리하는 가장 중요한 기준은 아마도 시스템에서 각 모듈이 자신을 제외한 다른 부분에 드러내지 않아야 할 비밀을 얼마나 잘 숨기느냐에 있을 것이다.

## 레코드 캡슐화하기 \_ Encapsulate Record

1. 배경

   - 단순한 레코드는 계산해서 얻을 수 있는 값과 그렇지 않은 값을 명확히 구분해 저장해야 한다는 단점이 있다.
   - 가변 데이터를 저장하는 용도로는 레코드보다 객체를 선호하는 편이다. 불변이라면 레코드에 저장한다.
   - 레코드의 구조는 필드 이름을 노출하는 형태와 내가 원하는 이름을 쓸 수 있는 형태 두 가지로 구분할 수 있고, 후자의 경우 hash, map, hashmap, dictionary, associative array 등의 이름으로 라이브러리에서 제공한다.
   - 해시맵은 필드를 명확히 알려주지 않는다는 단점이 있는데, 사용되는 부분이 적다면 문제되지 않지만 사용하는 곳이 많을수록 불분명함으로 인해 발생하는 문제가 커지게 되므로 명시적 레코드 혹은 클래스로 리팩터링하는 것이 좋다.

2. 절차

   - 레코드를 담은 변수를 캡슐화한다.
   - 레코드를 감싼 단순한 클래스로 해당 변수의 내용을 교체한다. 이 클래스에 원본 레코드를 반환하는 접근자도 정의하고, 변수를 캡슐화하는 함수들이 이 접근자를 사용하도록 수정한다.
   - 테스트한다.
   - 원본 레코드 대신 새로 정의한 클래스 타입의 객체를 반환하는 함수들을 새로 만든다.
   - 레코드를 반환하는 예전 함수를 사용하는 코드를 새로 만든 함수를 사용하도록 바꾼다. 필드에 접근할 때는 객체의 접근자를 사용한다. 적절한 접근자가 없다면 추가한다. 한 부분을 바꿀 때마다 테스트한다.
   - 클래스에서 원본 데이터를 반환하는 접근자와 원본 레코드를 반환하는 함수들을 제거한다.
   - 테스트한다.
   - 레코드의 필드도 데이터 구조인 중첩 구조라면 레코드 캡슐화하기와 컬렉션 캡슐화하기를 재귀적으로 적용한다.

3. 예시
   - [간단한 레코드 캡슐화하기](ex_7_1/1.js)
   - [중첩된 레코드 캡슐화하기](ex_7_1/2.js)
