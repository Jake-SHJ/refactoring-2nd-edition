# chapter 3 코드에서 나는 악취

> _냄새 나면 당장 갈아라. - 켄트 벡 할머니의 육아 원칙_

## 기이한 이름 \_ Mysterious Name

- 함수, 모듈, 변수, 클래스 등은 그 이름만 보고도 각각이 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있도록 엄청나게 신경 써서 이름을 지어야 한다.
- 이름만 잘 지어도 나중에 문맥을 파악하느라 헤매는 시간을 크게 절약할 수 있다.
- 마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높다.

## 중복 코드 \_ Duplicated Code

- 똑같은 코드 구조가 여러 곳에서 반복된다면 하나로 통합하여 더 나은 프로그램을 만들 수 있다.

## 긴 함수 \_ Long Function

- 간접 호출의 효과, 즉 코드를 이해하고, 공유하고, 선택하기 쉬워진다는 장점은 함수를 짧게 구성할 때 나오는 것이다.
- 짧은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 확실한 방법은 좋은 이름이다.
- 주석을 달아야 할 만한 부분은 무조건 함수로 만든다. 함수 이름은 동작 방식이 아닌 '의도'가 드러나게 짓는다. 핵심은 함수의 길이가 아닌, 함수의 목적(의도)과 구현 코드의 괴리가 얼마나 큰가다. 즉, '무엇을 하는지'를 코드가 잘 설명해주지 못할수록 함수로 만드는 게 유리하다.
- 추출할 코드 덩어리는 주석을 참고하거나, 조건문이나 반복문이 추출 대상의 실마리를 제공한다. 주석은 코드만으로는 목적을 이해하기 어려운 부분에 달려 있는 경우가 많다.

> 코드가 단 한 줄이어도 따로 설명할 필요가 있다면 함수로 추출하는 게 좋다.

## 긴 매개변수 목록 \_ Long Parameter List

- 매개변수 목록이 길어지면 그 자체로 이해하기 어려울 때가 많다.
- 다른 매개변수에서 값을 얻어올 수 있는 매개변수는 _매개변수를 질의 함수로 바꾸기_ 로 제거할 수 있다.
- 데이터에서 값들을 뽑아 각각을 별개의 매개변수로 전달하는 코드라면 _객체 통째로 넘기기_ 를 적용해서 원본 데이터 구조를 그대로 전달한다.
- 항상 함께 전달되는 매개변수들은 _매개변수 객체 만들기_ 로 하나로 묶어버린다.
- 플래그 역할의 매개 변수는 _플래그 인수 제거하기_ 로 없애준다.
- 클래스는 매개변수 목록을 줄이는 데 효과적인 수단이다.

## 전역 데이터 \_ Global Data

- 전역 데이터는 코드베이스 어디에서든 건드릴 수 있고 값을 누가 바꿨는지 찾아낼 메커니즘이 없다는 게 문제다.
- 함수로 감싸는 것만으로도 데이터를 수정하는 부분을 쉽게 찾을 수 있고 접근을 통제할 수 있게 된다.
- 전역 데이터가 가변이라면 특히나 다루기 까다롭다.
- 전역 데이터가 많아지면 걷잡을 수 없게 되므로 아주 조금만 있더라도 캡슐화를 하는 것이 좋다.

## 가변 데이터 \_ Mutable Data

- 코드의 다른 곳은 다른 값을 기대한다는 사실을 인식하지 못한 채 수정해버리면 프로그램이 오작동한다.
- 함수형 프로그래밍에서는 데이터는 절대 변하지 않고, 데이터를 변경하려면 반드시 변경하려는 값에 해당하는 복사본을 만들어서 반환한다는 개념을 기본으로 삼고 잇다.
- 무분별한 데이터 수정에 따른 위험을 줄이는 방법은 얼마든지 있다.
  - 함수를 거쳐야만 값을 수정할 수 있도록 하거나, 용도별로 독립 변수에 저장하게 한다.
  - 값을 다른 곳에서 설정할 수 있는 가변 데이터는 _파생 변수를 질의 함수로 바꾸기_ 로 리팩터링한다.
  - 변수 유효 범위를 제한한다.
  - 구조체처럼 내부 필드에 데이터를 담고 있는 변수라면, 내부 필드를 직접 수정하지 말고 구조체를 통째로 교체하는 편이 낫다.

## 뒤엉킨 변경 \_ Divergent Change

- 뒤엉킨 변경은 단일 책임 원칙 (Single Responsibility Principle)이 제대로 지켜지지 않을 때 나타난다.
- 즉, 하나의 모듈이 서로 다른 이유들로 인해 여러 가지 방식으로 변경되는 일이 많을 때 발생한다.
- 단계를 분리하거나 함수 또는 클래스를 추출하고 관련 함수를 모으는 것을 통해 처리 과정을 맥락별로 구분되게 한다.

## 산탄총 수술 \_ Shotgun Surgery

- 뒤엉킨 변경처럼 맥락을 잘 구분하지 못할 때 발생하지만, 뒤엉킨 변경은 한 코드에 섞여있는 경우고 산탄총 수술의 경우 여러 코드에 흩뿌려진 경우이다.
- 뒤엉킨 변경과 반대로 함께 변경되는 대상들을 한 모듈로 묶고, 비슷한 데이터를 다루는 함수가 많다면 클래스로 묶는다.
- 어설프게 분리된 로직은 _함수 인라인하기_ 나 _클래스 인라인하기_ 같은 인라인 리팩터링으로 하나로 합치는 것이 좋다.

## 기능 편애 \_ Feature Envy

- 기능 편애는 흔히 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용을 할 일이 더 많을 때 풍기는 냄새이다.
- 자주 상호작용하는 데이터 근처로 옮겨주거나, 독립 함수로 추출하여 원하는 모듈로 보내준다.
- 어디로 옮길지 명확하지 않은 경우 가장 많은 데이터를 포함한 모듈로 옮긴다. 또는 함수를 여러 조각으로 나눈 후 각각을 적합한 모듈로 옮긴다.

## 데이터 뭉치 \_ Data Clumps

- 데이터 항목들은 서로 어울려 노는 것을 좋아해서, 서너 개가 여러 곳에서 항상 함께 뭉쳐 다니는 모습을 흔히 목격할 수 있다.
- 필드 형태의 데이터 뭉치는 클래스로 추출하고 메서드 시그니처에 있는 데이터 뭉치는 매개변수 수만 줄여도 코드가 간결해질 수 있다.
- 데이터 뭉치인지 판별하려면 값 하나를 삭제했을 때 나머지 데이터만으로는 의미가 없다면 객체로 환생하길 갈망하는 데이터 뭉치라는 뜻이다.

## 기본형 집착 \_ Primitive Obsession

- 전화번호를 단순히 문자 집합으로만 표현하기엔 아쉬움이 많다.
- 최소한 사용자에게 보여줄 때는 일관된 형식으로 출력해주는 기능이라도 갖춰야한다. (소위 '문자열화된(stringly typed)' 변수)
- 기본형을 객체로 바꾸거나, 기본형으로 표현된 코드가 조건부 동작을 제어하는 타입 코드로 쓰인 경우, 서브 클래스로 바꾸고 조건부 로직을 다형성으로 바꾼다.
