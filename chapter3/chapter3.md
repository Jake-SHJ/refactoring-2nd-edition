# chapter 3 코드에서 나는 악취

> _냄새 나면 당장 갈아라. - 켄트 벡 할머니의 육아 원칙_

## 기이한 이름 \_ Mysterious Name

- 함수, 모듈, 변수, 클래스 등은 그 이름만 보고도 각각이 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있도록 엄청나게 신경 써서 이름을 지어야 한다.
- 이름만 잘 지어도 나중에 문맥을 파악하느라 헤매는 시간을 크게 절약할 수 있다.
- 마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높다.

## 중복 코드 \_ Duplicated Code

- 똑같은 코드 구조가 여러 곳에서 반복된다면 하나로 통합하여 더 나은 프로그램을 만들 수 있다.

## 긴 함수 \_ Long Function

- 간접 호출의 효과, 즉 코드를 이해하고, 공유하고, 선택하기 쉬워진다는 장점은 함수를 짧게 구성할 때 나오는 것이다.
- 짧은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 확실한 방법은 좋은 이름이다.
- 주석을 달아야 할 만한 부분은 무조건 함수로 만든다. 함수 이름은 동작 방식이 아닌 '의도'가 드러나게 짓는다. 핵심은 함수의 길이가 아닌, 함수의 목적(의도)과 구현 코드의 괴리가 얼마나 큰가다. 즉, '무엇을 하는지'를 코드가 잘 설명해주지 못할수록 함수로 만드는 게 유리하다.
- 추출할 코드 덩어리는 주석을 참고하거나, 조건문이나 반복문이 추출 대상의 실마리를 제공한다. 주석은 코드만으로는 목적을 이해하기 어려운 부분에 달려 있는 경우가 많다.

> 코드가 단 한 줄이어도 따로 설명할 필요가 있다면 함수로 추출하는 게 좋다.

## 긴 매개변수 목록 \_ Long Parameter List

- 매개변수 목록이 길어지면 그 자체로 이해하기 어려울 때가 많다.
- 다른 매개변수에서 값을 얻어올 수 있는 매개변수는 _매개변수를 질의 함수로 바꾸기_ 로 제거할 수 있다.
- 데이터에서 값들을 뽑아 각각을 별개의 매개변수로 전달하는 코드라면 _객체 통째로 넘기기_ 를 적용해서 원본 데이터 구조를 그대로 전달한다.
- 항상 함께 전달되는 매개변수들은 _매개변수 객체 만들기_ 로 하나로 묶어버린다.
- 플래그 역할의 매개 변수는 _플래그 인수 제거하기_ 로 없애준다.
- 클래스는 매개변수 목록을 줄이는 데 효과적인 수단이다.

## 전역 데이터 \_ Global Data

- 전역 데이터는 코드베이스 어디에서든 건드릴 수 있고 값을 누가 바꿨는지 찾아낼 메커니즘이 없다는 게 문제다.
- 함수로 감싸는 것만으로도 데이터를 수정하는 부분을 쉽게 찾을 수 있고 접근을 통제할 수 있게 된다.
- 전역 데이터가 가변이라면 특히나 다루기 까다롭다.
- 전역 데이터가 많아지면 걷잡을 수 없게 되므로 아주 조금만 있더라도 캡슐화를 하는 것이 좋다.

## 가변 데이터 \_ Mutable Data

- 코드의 다른 곳은 다른 값을 기대한다는 사실을 인식하지 못한 채 수정해버리면 프로그램이 오작동한다.
- 함수형 프로그래밍에서는 데이터는 절대 변하지 않고, 데이터를 변경하려면 반드시 변경하려는 값에 해당하는 복사본을 만들어서 반환한다는 개념을 기본으로 삼고 잇다.
- 무분별한 데이터 수정에 따른 위험을 줄이는 방법은 얼마든지 있다.
  - 함수를 거쳐야만 값을 수정할 수 있도록 하거나, 용도별로 독립 변수에 저장하게 한다.
  - 값을 다른 곳에서 설정할 수 있는 가변 데이터는 _파생 변수를 질의 함수로 바꾸기_ 로 리팩터링한다.
  - 변수 유효 범위를 제한한다.
  - 구조체처럼 내부 필드에 데이터를 담고 있는 변수라면, 내부 필드를 직접 수정하지 말고 구조체를 통째로 교체하는 편이 낫다.

## 뒤엉킨 변경 \_ Divergent Change

- 뒤엉킨 변경은 단일 책임 원칙 (Single Responsibility Principle)이 제대로 지켜지지 않을 때 나타난다.
- 즉, 하나의 모듈이 서로 다른 이유들로 인해 여러 가지 방식으로 변경되는 일이 많을 때 발생한다.
- 단계를 분리하거나 함수 또는 클래스를 추출하고 관련 함수를 모으는 것을 통해 처리 과정을 맥락별로 구분되게 한다.

## 산탄총 수술 \_ Shotgun Surgery

- 뒤엉킨 변경처럼 맥락을 잘 구분하지 못할 때 발생하지만, 뒤엉킨 변경은 한 코드에 섞여있는 경우고 산탄총 수술의 경우 여러 코드에 흩뿌려진 경우이다.
- 뒤엉킨 변경과 반대로 함께 변경되는 대상들을 한 모듈로 묶고, 비슷한 데이터를 다루는 함수가 많다면 클래스로 묶는다.
- 어설프게 분리된 로직은 _함수 인라인하기_ 나 _클래스 인라인하기_ 같은 인라인 리팩터링으로 하나로 합치는 것이 좋다.

## 기능 편애 \_ Feature Envy

- 기능 편애는 흔히 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용을 할 일이 더 많을 때 풍기는 냄새이다.
- 자주 상호작용하는 데이터 근처로 옮겨주거나, 독립 함수로 추출하여 원하는 모듈로 보내준다.
- 어디로 옮길지 명확하지 않은 경우 가장 많은 데이터를 포함한 모듈로 옮긴다. 또는 함수를 여러 조각으로 나눈 후 각각을 적합한 모듈로 옮긴다.

## 데이터 뭉치 \_ Data Clumps

- 데이터 항목들은 서로 어울려 노는 것을 좋아해서, 서너 개가 여러 곳에서 항상 함께 뭉쳐 다니는 모습을 흔히 목격할 수 있다.
- 필드 형태의 데이터 뭉치는 클래스로 추출하고 메서드 시그니처에 있는 데이터 뭉치는 매개변수 수만 줄여도 코드가 간결해질 수 있다.
- 데이터 뭉치인지 판별하려면 값 하나를 삭제했을 때 나머지 데이터만으로는 의미가 없다면 객체로 환생하길 갈망하는 데이터 뭉치라는 뜻이다.

## 기본형 집착 \_ Primitive Obsession

- 전화번호를 단순히 문자 집합으로만 표현하기엔 아쉬움이 많다.
- 최소한 사용자에게 보여줄 때는 일관된 형식으로 출력해주는 기능이라도 갖춰야한다. (소위 '문자열화된(stringly typed)' 변수)
- 기본형을 객체로 바꾸거나, 기본형으로 표현된 코드가 조건부 동작을 제어하는 타입 코드로 쓰인 경우, 서브 클래스로 바꾸고 조건부 로직을 다형성으로 바꾼다.

## 반복되는 switch문 \_ Repeated Switches

- 똑같은 조건부 로직이 여러 곳에서 반복해 등장하는 코드에 집중한다.
- 중복된 switch문이 문제가 되는 이유는 조건절을 하나 추가할 때마다 다른 switch문들도 모두 찾아서 함께 수정해야 하기 때문이다.
- _조건부 로직을 다형성으로 바꾸기_ 를 통해 해결할 수 있다.

## 반복문 \_ Loops

- 일급 함수(first-class function)를 지원하는 언어가 많아졌기 때문에 _반복문을 파이프라인으로 바꾸기_ 를 적용해서 반복문을 제거할 수 있다.

## 성의 없는 요소 \_ Lazy Element

- 여기서의 요소는 언어가 제공하는 메서드, 클래스, 인터페이스 등을 뜻한다.
- 요소가 굳이 필요없는 경우, 예를 들어 메서드가 하나뿐인 클래스일 때 _함수 인라인하기_ 나 _클래스 인라인하기_ 로 처리하고, 상속을 사용한 경우 _계층 합치기_ 를 적용한다.

## 추측성 일반화 \_ Speculative Generality

- '나중에 필요할 거야'라는 생각으로 당장은 필요 없는 모든 종류의 후킹 포인트와 특이 케이스 처리 로직을 작성해둔 코드에서 풍긴다.
- 추측성 일반화는 테스트 코드 말고는 사용하는 곳이 없는 함수나 클래스에서 흔히 볼수 있다.
- 테스트 케이스부터 삭제하고 _죽은 코드 제거하기_ 로 날려버리자.

## 임시 필드 \_ Temporary Field

- 특정 상황에서만 값이 설정되는 필드를 가진 클래스도 있다.
- 객체를 가져올 때 모든 필드가 채워져 있으리라 기대하므로, 임시 필드를 갖는 코드는 이해하기 어렵다.
- 덩그러니 떨어져 있는 필드는 _클래스 추출하기_ 를 통해 제 살 곳을 찾아주고, _함수 옮기기_ 로 임시 필드와 관련된 코드를 모조리 새 클래스에 몰아넣는다.
- 임시 필드들의 유효성을 확인 후 동작하는 조건부 로직은 _특이 케이스 추가하기_ 로 필드들이 유효하지 않을 때를 위한 대안 클래스를 만들어 제거할 수 있다.

## 메시지 체인 \_ Message Chain

- 메시지 체인은 클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤 방금 얻은 객체에 또 다른 객체를 요청하는 식으로, 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드를 말한다.
- _위임 숨기기_ 로 해결한다. 중간 객체들이 모두 중개자가 될 수 있으므로, 최종 결과 객체가 어떻게 쓰이는지부터 살펴보는 게 좋다.

## 중개자 \_ Middle Man

- 캡슐화하는 과정에서는 위임이 자주 활용되는데 지나치면 문제가 된다. (클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임하고 있는 경우라던지.)
- 실제로 일을 하는 객체와 직접 소통하게 한다. 위임 메서드를 제거한 후 남는 일이 거의 없다면 호출하는 쪽으로 인라인한다.

## 내부자 거래 \_ Insider Trading

- 일이 돌아가게 하려면 모듈 사이의 데이터 거래가 이뤄질 수 밖에 없지만, 그 양을 최소로 줄이고 모두 투명하게 처리해야 한다.
- 은밀히 데이터를 주고 받는 모듈이 있다면 사적으로 처리하는 부분을 줄인다.
- 여러 모듈이 같은 관심사를 공유한다면 공통 부분을 정식으로 처리하는 제3의 모듈을 새로 만들거나 다른 모듈이 중간자 역할을 하게 만든다.
- 상속 구조에서 부모 클래스가 공개하고 싶은 것 이상으로 부모에 대해 알려고 한다면 _서브클래스 또는 슈퍼클래스를 위임으로 바꾸기_ 를 활용한다.

## 거대한 클래스 \_ Large Class

- 한 클래스가 너무 많은 일을 하려다 보면 필드 수가 상당히 늘어난다.
- 클래스에 필드가 너무 많으면 중복 코드가 생기기 쉽다.
- 가장 간단한 해법은 클래스 안에서 자체적으로 중복을 제거하는 것이다.

## 서로 다른 인터페이스의 대안 클래스들 \_ Alternative Classes with Different Interfaces

- 클래스를 사용할 때의 큰 장점은 필요에 따라 언제든 다른 클래스로 교체할 수 있다는 것이지만, 단 인터페이스가 같아야 한다.
- 따라서 _함수 선언 바꾸기_ 로 메서드 시그니처를 일치시키고, 부족한 경우 _함수 옮기기_ 를 이용하여 인터페이스가 같아질 때까지 필요한 동작들을 클래스 안으로 밀어 넣는다.
- 그러다 대안 클래스들 사이에 중복 코드가 생기면 _슈퍼클래스 추출하기_ 를 적용할지 고려한다.

## 데이터 클래스 \_ Data Class

- 데이터 클래스란 데이터 필드와 게터/세터 메서드로만 구성된 클래스를 말한다.
- 데이터 클래스는 필요한 동작이 엉뚱한 곳에 정의돼 있다는 신호일 수 있다.
- 불변 필드는 굳이 캡슐화할 필요가 없고, 불변 데이터로 나오는 정보는 게터를 통하지 않고 그냥 필드 자체를 공개해도 된다.

## 상속 포기 \_ Refused Bequest

- 서브클래스가 관심있는 유산 몇 개만 받고 끝내려는 경우는 얼마든지 있을 수 있다.
- 상속 포기 냄새는 서브클래스가 부모의 동작은 필요로하지만 인터페이스는 따르고 싶지 않을 때 특히 심하게 난다.
- _서브클래스 또는 슈퍼클래스를 위임으로 바꾸기_ 를 통해 아예 상속 메커니즘에서 벗어날 수 있다.

## 주석 \_ Comments

- 주석이 장황하게 달린 원인이 코드를 잘못 작성했기 때문인 경우가 많다. (주석을 탈취제처럼 사용한 경우이다)

> 주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요 없는 코드로 리팩터링해본다.

- 뭘 할지 모를 때라면 주석을 달아두면 좋다. 현재 진행 상황, 확식하지 않은 부분에 주석을 남긴다.
- 코드를 지금처럼 작성한 이유를 설명하는 용도로 달 수도 있다. (코드를 수정해야 할 프로그래머, 혹은 건망증이 심한 프로그래머에게 도움이 될 것이다.)
